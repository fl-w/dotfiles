#!/bin/bash
#   ███                      █████              ████  ████
#  ▒▒▒                      ▒▒███              ▒▒███ ▒▒███
#  ████  ████████    █████  ███████    ██████   ▒███  ▒███
# ▒▒███ ▒▒███▒▒███  ███▒▒  ▒▒▒███▒    ▒▒▒▒▒███  ▒███  ▒███
#  ▒███  ▒███ ▒███ ▒▒█████   ▒███      ███████  ▒███  ▒███
#  ▒███  ▒███ ▒███  ▒▒▒▒███  ▒███ ███ ███▒▒███  ▒███  ▒███
#  █████ ████ █████ ██████   ▒▒█████ ▒▒████████ █████ █████
# ▒▒▒▒▒ ▒▒▒▒ ▒▒▒▒▒ ▒▒▒▒▒▒     ▒▒▒▒▒   ▒▒▒▒▒▒▒▒ ▒▒▒▒▒ ▒▒▒▒▒
#
# Simple dots install script
# Do not edit after this line unless you know what you are doing


PROGRAM_NAME=$(basename "$0")

VERBOSE=1

ROOT_DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" &>/dev/null && pwd )"

CLEANING_UP=0

TEMP_DIR=$(mktemp)

ALL_PACAKGES=0

SKIP_SELECTION=1

IGNORE="refind anne-pro-2-kb"
STOW_IGNORE="post-install deps"

. utils.sh

select_dots() {
  local packages=($(ls -d */ | cut -f 1 -d '/'))
  local ignores=(${IGNORE[@]})

  for ignore in ${ignores[@]}; do
    for i in "${!packages[@]}"; do
      if [[ ${packages[i]} = $ignore ]]; then unset 'packages[i]'; fi
    done
  done

  if [[ "$SKIP_SELECTION" == 1 ]]; then
     select_options "Select packages to install" $ALL_PACAKGES "${packages[@]}"
    DOTS=${selected[@]}
  else
    DOTS=${packages[@]}
  fi
}

load_deps() {
  if [[ ${#DOTS} -eq 0 ]]; then
    print_info "No dots selected, nothing to do."
    exit 0
  fi

  print_info "Searching for package dependencies"

  DEPS_PACMAN=""
  DEPS_PY=""
  DEPS_NODE=""
  DEPS_AUR=""

  for pkg in ${DOTS[@]}; do

    if [ -f $pkg/deps ]; then

      while read line; do
        if echo $line | grep -F = &>/dev/null; then

          local deps=$(echo "$line" | cut -d '=' -f 2-)

          case "$(echo "$line" | cut -d '=' -f 1)" in
            py|python|py_pkgs)
              DEPS_PY="$DEPS_PY $deps"
              ;;
            pkgs)
              DEPS_PACMAN="$DEPS_PACMAN $deps"
              ;;
            node)
              DEPS_NODE="$DEPS_NODE $deps"
              ;;
            alt_pkgs|aur)
              DEPS_AUR="$DEPS_AUR $deps"
              ;;
          esac
        fi
      done < $pkg/deps

    else
      print_debug '%s has no deps -- skipping' $pkg
      continue
    fi
  done


  local all_deps=("DEPS_PACMAN DEPS_PY DEPS_AUR DEPS_NODE")
  for i in ${all_deps[@]}; do
    local p="${!i}"

    p="$(sed -e 's/[[:space:]]*$//' <<<${p})" # trim trailing spaces
    p=$(echo "${p}" | xargs -n1 | sort -u | xargs) # remove dups

    declare -gx "$i=$p "
  done

  print_debug "done"
}

is_using_arch() {
  find_distro_name() {
    distro=$(cat /proc/version | awk -F'[()]' '{print $5}')
  }

  [[ -z "$distro" ]] && find_distro_name

  case $distro in
    Arch\ Linux*) return 0;;
    *) return 1;;
  esac
}

install_dots() {
  print_info "Installing package dependencies"

  find_pacman() {
    case $distro in
      Manjaro*|Arch*) printf "/usr/bin/pacman -S --needed";;
      Debian*) printf '/usr/bin/apt-install';;
      *) printf '';;
    esac
  }

  is_using_arch || {
    print_warning "Oh oh, it looks like you are not on Arch Linux."

    # find pacman
    installer=$(find_pacman)

    read -rp "Enter the command for your package installer [$installer]: " installerc
    installer=${installerc:-$installer}

    if [[ ! -f $(echo $installer | cut -d' ' -f1) ]]; then
      print_err "Couldn't find bin at that path $installer"
      return 1;
    fi

  }

  installer=${installer-$(find_pacman)}

  if is_using_arch; then
    pkgs=$(pacman -Qqs $(echo $DEPS_PACMAN | tr ' ' '|') | tr '\n' '|')
    DEPS_PACMAN=$(echo $DEPS_PACMAN | tr ' ' '\n' | grep -vE "${pkgs::-1}" | tr '\n' ' ')
  fi

  if [[ ! -z "$DEPS_PACMAN" ]]; then
    local deps=(${DEPS_PACMAN})
    for i in ${deps[@]}; do
      print_info "> installing pacman dep: %s" $i
      print_debug "$ sudo $installer $i"

      verbose_command yes | sudo $installer $i || {
        print_err "could not install $1" && \
        { if ! prompt "continue"; then return 1; fi; }
      } && print_success "installed $i"

    done

    print_success "installed %d total packages." $(echo $DEPS_PACMAN | tr ' ' '\n' | wc -l)
    return 0
  else
    print_debug 'All deps installed already.'
    return 0
  fi
}

install_generic() {
  local name=$1
  local bin=$2
  local deps=(${!3})
  local bin_installer=$4
  local installer=$5

  print_info "Installing $name dependencies with $bin"

  require $bin $bin_installer || return 0

  for i in ${deps[@]}; do
    print_info "-- installing $name dependency: %s" $i

    verbose_command $installer $i || {
      print_err "could not install $i";
      if ! prompt "Want to continue?"; then return 1; fi;
    }

  done

  print_debug 'done'
}

install_aur_deps() {
  is_using_arch || return 0;

  install_generic AUR yay DEPS_AUR install_yay "yay --noconfirm --needed --noredownload --norebuild -S"
}

install_py_deps() {
  install_generic python-pip pip3 DEPS_PY install_pip "pip3 install --user"
}

install_node_deps() {
  install_generic node npm DEPS_NODE install_node "npm -g i"
}

stow_packages() {
  install_stow() {
    verbose_command sudo $installer stow
  }

  print_info "Stowing packages to home."

  # check if has packages to stow

  local dashv=""

  if is_using_arch; then
    require stow install_stow || return 0
  else
    require stow || return 0
  fi

  [[ "$VERBOSE" -eq 2 ]] && dashv="-v"

  local ignores=(${STOW_IGNORE})
  local stow="stow $dashv --dotfiles -d $ROOT_DIR -t $HOME"

  for ignore in ${ignores[@]}; do
    stow="$stow --ignore $ignore"
  done

  print_debug $stow
  for pkg in ${DOTS[@]}; do
    print_debug "> stowing %s" $pkg
    $stow -R "$pkg" 3>&1 1>&2 2>&3 3>&- | grep -- '=' && print_success "stowed $pkg dots." $pkg || \
      { print_err "Issue whilst creating symmlink for $pkg"; }
  done

  return 0
}

post_install() {
  print_info "running post install"

  for dot in ${DOTS[@]}; do
    if [ -f $ROOT_DIR/$dot/post-install ]
    then
      SECONDS=0
      . $ROOT_DIR/$dot/post-install
      print_success "$dot post install took ${SECONDS}s."
    fi
  done
}

print_banner() {
  cat <<- EOF
    ██████           ████                          ███
   ███▒▒███         ▒▒███                         ▒███
  ▒███ ▒▒▒   ██████  ▒███  █████ ███ █████  █████ ▒███
 ███████    ███▒▒███ ▒███ ▒▒███ ▒███▒▒███  ███▒▒  ▒███
▒▒▒███▒    ▒███ ▒███ ▒███  ▒███ ▒███ ▒███ ▒▒█████ ▒███
  ▒███     ▒███ ▒███ ▒███  ▒▒███████████   ▒▒▒▒███▒▒▒
  █████    ▒▒██████  █████  ▒▒████▒████    ██████  ███
 ▒▒▒▒▒      ▒▒▒▒▒▒  ▒▒▒▒▒    ▒▒▒▒ ▒▒▒▒    ▒▒▒▒▒▒  ▒▒▒

EOF
}

show_help() {
  if [ -n "$1" ]; then
    print_err "$1"
  fi

  # Display Help
  print_banner
  print_info "Install and stow dots in home directory"
  echo
  echo "Usage: $PROGRAM_NAME [ options ... ]"
  echo "optional arguments:"
  echo " -h, --help                   show this help text"
  echo " -a, --all                    select all packages. "
  echo " -i, --ignore \"file,file2,...\""
  echo "                              ignore dots."
  echo " -r, --stow-ignore \"file,file2,...\""
  echo "                              ignore stowing files"
  echo " -Y, --skip-select            skip dots pack selection. "
  # echo " -K, --skip-install           skip installing dependencies. "
  # echo " --skip-aur                   skip installing aur dependencies. "
  # echo " --skip-stow                  skip stowing dotfiles. "
  echo " -q, --quiet                  quiet mode, don't print anything."
  echo " -v, --verbose                run in verbose mode."
  echo
}

ignore() {
  test -z "$3" && quit "please provide argument to $2"

  local ignores=$(get_list_opt $3)
  declare -gx "$1=${!1} $ignores"
}


parse_opts() {
  while [[ "$1" =~ ^- && ! $1 == "--" ]]; do case $1 in
    -h|--help) show_help; exit 0;;
    -a|--all) ALL_PACAKGES=1;;
    -i|--ignore) ignore IGNORE ignore $2; shift;;
    -k|--stow-ignore) ignore STOW_IGNORE stow $2; shift;;
    -Y|--skip-select) SKIP_SELECTION=0;;
    -q|--quiet) VERBOSE=0;;
    -v|--verbose) VERBOSE=2;;
    *) show_help "Unknown parameter: $1"; exit 1;;

  esac; shift; done
  if [[ "$1" == '--' ]]; then shift; fi
}

main() {
  parse_opts "$@"

  if [[ "$VERBOSE" -eq 0 ]]; then
    exec >/dev/null 2>&1
  fi

  pushd $ROOT_DIR >/dev/null

  select_dots || quit

  load_deps || quit

  sudo -k

  install_dots || quit

  install_aur_deps || quit

  install_py_deps || quit

  install_node_deps || quit

  stow_packages || quit

  post_install || quit

  print_banner

  print_success
  print_success "--- done ! installed %d dots ---" ${#DOTS}
  print_success

  exit 0
}

do_cleanup() {
  # Guard clause so that it's only ran once
  if [[ "$CLEANING_UP" == "1" ]]; then return; fi
  CLEANING_UP=1

  print_debug "cleaning up"

  rm -r $TEMP_DIR
}

quit () {
  [ ! -z "$1" ] && print_err $@

  do_cleanup
  exit 1
}

trap quit INT
trap quit SIGHUP
trap quit SIGINT
trap quit SIGTERM
main "$@"
